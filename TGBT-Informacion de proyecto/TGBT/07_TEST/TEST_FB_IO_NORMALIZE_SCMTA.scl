(*
================================================================================
  FB_TEST_SCMTA: Test Automatizado FB_IO_NORMALIZE + FB_SCMTA
  Versión: 1.0
  Fecha: 2026-02-05
================================================================================
  DESCRIPCIÓN:
  Test secuencial con delays para validar paso a paso el comportamiento
  de FB_IO_NORMALIZE y FB_SCMTA.
  
  PASOS DEL TEST:
  0. Inicialización (5s delay)
  1. Operación normal en RED (3s)
  2. Simulación falla de red (espera detección)
  3. Apertura QT1 (simulada con delay)
  4. Arranque GD (2s delay)
  5. GD listo (3s delay)
  6. Cierre QG1 (simulado con delay)
  7. Operando con GD (5s)
  8. Retorno de red (espera detección)
  9. Test pulsadores manuales (10s)
  10. Test finalizado
  
  INSTRUCCIONES:
  1. Llamar desde Main (crear instance DB)
  2. Activar testEnable = TRUE en el instance DB
  3. Observar testStep y testStatus en watch table
  4. Cada paso espera un tiempo antes de avanzar
  5. Verificar resultados esperados en cada paso
  
================================================================================
*)

FUNCTION_BLOCK "FB_TEST_SCMTA"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

VERSION : 0.1

VAR 
    // ========== CONTROL FIRST SCAN ==========
    firstScanDone : Bool := FALSE;  // Flag para ejecutar inicialización solo una vez
    
    // ========== CONTROL TEST ==========
    testEnable : Bool := FALSE;  // Activar para iniciar test
    testStep : Int := 0;  // Paso actual del test
    testStatus : String[100] := 'Test detenido - Activar testEnable para iniciar';  // Descripción del paso
    testExpectedState : Int := 0;  // Estado SCMTA esperado
    testExpectedResult : String[50] := '';  // Resultado esperado
    
    // ========== SIMULACIÓN ENTRADAS FÍSICAS ==========
    simDI_SYS_AUTO : Bool := TRUE;
    simDI_QT1_REMOTE_SEL : Bool := TRUE;
    simDI_QT1_PB_OPEN : Bool := FALSE;
    simDI_QT1_PB_CLOSE : Bool := FALSE;
    simDI_QG1_REMOTE_SEL : Bool := TRUE;
    simDI_QG1_PB_OPEN : Bool := FALSE;
    simDI_QG1_PB_CLOSE : Bool := FALSE;
    simDI_GD_READY : Bool := FALSE;
    simDI_GD_RUNNING : Bool := FALSE;
    simDI_GD_ALARM : Bool := FALSE;
    
    // ========== SIMULACIÓN ESTADOS INTERRUPTORES ==========
    simQT1_STATE : Int := 1;  // 0=Abierto, 1=Cerrado (operando con RED)
    simQG1_STATE : Int := 0;  // Abierto (GD desconectado)
    simQG2_STATE : Int := 0;  // Abierto
    
    // ========== SIMULACIÓN MEDICIONES RED ==========
    simGridV_L1L2 : Real := 380.0;
    simGridV_L2L3 : Real := 380.0;
    simGridV_L3L1 : Real := 380.0;
    simGridFreq : Real := 50.0;
    simGridMeasurementOk : Bool := TRUE;
    
    // ========== CONTROL ==========
    simRESET_FAULT : Bool := FALSE;
    
    // ========== OUTPUTS FB_IO_NORMALIZE ==========
    outModeAuto : Bool;
    outReqManQT1_Open : Bool;
    outReqManQT1_Close : Bool;
    outGD_Ready : Bool;
    outGD_Running : Bool;
    
    // ========== OUTPUTS FB_SCMTA ==========
    outState : Int;
    outStateName : String[30];
    outReqScmtaOpenQT1 : Bool;
    outReqScmtaCloseQT1 : Bool;
    outReqScmtaOpenQG1 : Bool;
    outReqScmtaCloseQG1 : Bool;
    outDoGD_Start : Bool;
    outDoGD_Stop : Bool;
    outIsOnGrid : Bool;
    outIsOnGD : Bool;
    outIsInTransfer : Bool;
    outGridOk : Bool;
    outGridFail : Bool;
    outElapsedTime : Time;
    
END_VAR

VAR STAT
    // ========== TIMER TEST (STATIC para mantener estado) ==========
    testTimer : TON;  // Timer para delays en secuencia
    
    // ========== INSTANCIAS FB ==========
    fbIoNormalize : FB_IO_NORMALIZE;
    fbScmta : FB_SCMTA;
END_VAR

BEGIN
    
    // ========================================================================
    // NETWORK 1: SECUENCIA DE TEST
    // ========================================================================
    
    IF #testEnable THEN
        
        CASE #testStep OF
            
            // PASO 0: Inicialización
            0:
                #testStatus := 'PASO 0: Inicializando test...';
                #testExpectedState := 0;
                #testExpectedResult := 'Debe llegar a estado INIT';
                
                // Configuración inicial
                #simDI_SYS_AUTO := TRUE;
                #simQT1_STATE := 1;
                #simQG1_STATE := 0;
                #simGridV_L1L2 := 380.0;
                #simGridV_L2L3 := 380.0;
                #simGridV_L3L1 := 380.0;
                #simGridFreq := 50.0;
                #simDI_GD_READY := FALSE;
                #simDI_GD_RUNNING := FALSE;
                
                #testTimer(IN := TRUE,
                           PT := T#5s);
               IF #testTimer.Q THEN
                   #testTimer(IN := FALSE,
                              PT := T#1s);
                    #testStep := 1;
                END_IF;
                
            // PASO 1: Operación normal en RED
            1:
                #testStatus := 'PASO 1: Operación normal RED - Esperando 3s';
                #testExpectedState := 1;
                #testExpectedResult := 'outState=1, outIsOnGrid=TRUE';
                
                #testTimer(IN := TRUE,
                           PT := T#3s);
               IF #testTimer.Q THEN
                   #testTimer(IN := FALSE,
                              PT := T#1s);
                    #testStep := 2;
                END_IF;
                
            // PASO 2: Simular falla de red
            2:
                #testStatus := 'PASO 2: Falla RED - Subtensión y subfrecuencia';
                #testExpectedState := 2;
                #testExpectedResult := 'outGridFail=TRUE, estado 2 o 3';
                
                #simGridV_L1L2 := 200.0;
                #simGridV_L2L3 := 200.0;
                #simGridV_L3L1 := 200.0;
                #simGridFreq := 48.0;
                
                // Esperar detección (filtro 2s + transición)
                #testTimer(IN := TRUE,
                           PT := T#4s);
               IF #testTimer.Q THEN
                   #testTimer(IN := FALSE,
                              PT := T#1s);
                    #testStep := 3;
                END_IF;
                
            // PASO 3: Simular apertura QT1
            3:
                #testStatus := 'PASO 3: Comando OPEN_QT1 recibido - Simulando apertura';
                #testExpectedState := 3;
                #testExpectedResult := 'outReqScmtaOpenQT1=TRUE';
                
                // Esperar comando
                IF #outReqScmtaOpenQT1 THEN
                    #testTimer(IN := TRUE,
                               PT := T#1s);
                   IF #testTimer.Q THEN
                        #simQT1_STATE := 0;  // Simular apertura
                        #testTimer(IN := FALSE,
                                   PT := T#1s);
                        #testStep := 4;
                    END_IF;
                END_IF;
                
            // PASO 4: Delay arranque GD y simular arranque
            4:
                #testStatus := 'PASO 4: QT1 abierto - Esperando delay y START_GD';
                #testExpectedState := 5;
                #testExpectedResult := 'outDoGD_Start=TRUE';
                
                // Esperar delay + comando start
                IF #outDoGD_Start THEN
                    #testTimer(IN := TRUE,
                               PT := T#2s);
                   IF #testTimer.Q THEN
                        #simDI_GD_RUNNING := TRUE;  // Simular GD arranca
                        #testTimer(IN := FALSE,
                                   PT := T#1s);
                        #testStep := 5;
                    END_IF;
                END_IF;
                
            // PASO 5: Simular GD listo
            5:
                #testStatus := 'PASO 5: GD corriendo - Simulando estabilización';
                #testExpectedState := 6;
                #testExpectedResult := 'Esperando GD_READY';
                
                #testTimer(IN := TRUE,
                           PT := T#3s);
               IF #testTimer.Q THEN
                    #simDI_GD_READY := TRUE;  // Simular GD listo
                    #testTimer(IN := FALSE,
                               PT := T#1s);
                    #testStep := 6;
                END_IF;
                
            // PASO 6: Esperar y simular cierre QG1
            6:
                #testStatus := 'PASO 6: GD listo - Esperando comando CLOSE_QG1';
                #testExpectedState := 7;
                #testExpectedResult := 'outReqScmtaCloseQG1=TRUE';
                
                // Esperar comando + delay estabilización (5s)
                #testTimer(IN := TRUE,
                           PT := T#6s);
               IF #testTimer.Q AND #outReqScmtaCloseQG1 THEN
                    #simQG1_STATE := 1;  // Simular cierre
                    #testTimer(IN := FALSE,
                               PT := T#1s);
                    #testStep := 7;
                END_IF;
                
            // PASO 7: Operando con GD
            7:
                #testStatus := 'PASO 7: Operando con GD - Esperando 5s';
                #testExpectedState := 8;
                #testExpectedResult := 'outIsOnGD=TRUE, outState=8';
                
                #testTimer(IN := TRUE,
                           PT := T#5s);
               IF #testTimer.Q THEN
                   #testTimer(IN := FALSE,
                              PT := T#1s);
                    #testStep := 8;
                END_IF;
                
            // PASO 8: Retorno de red
            8:
                #testStatus := 'PASO 8: Retorno RED - Restaurando parámetros';
                #testExpectedState := 9;
                #testExpectedResult := 'outGridOk=TRUE, estado 9 o 10';
                
                #simGridV_L1L2 := 380.0;
                #simGridV_L2L3 := 380.0;
                #simGridV_L3L1 := 380.0;
                #simGridFreq := 50.0;
                
                // Esperar detección (filtro 2s)
                #testTimer(IN := TRUE,
                           PT := T#3s);
               IF #testTimer.Q THEN
                   #testTimer(IN := FALSE,
                              PT := T#1s);
                    #testStep := 9;
                END_IF;
                
            // PASO 9: Test comandos manuales
            9:
                #testStatus := 'PASO 9: Test pulsadores - Generando pulsos';
                #testExpectedResult := 'outReqManQT1_Open debe pulsar';
                
                // Cambiar a modo manual
                #simDI_SYS_AUTO := FALSE;
                
                // Generar pulso pulsador cada 2s
                #testTimer(IN := TRUE,
                           PT := T#2s);
               IF #testTimer.Q THEN
                    #simDI_QT1_PB_OPEN := NOT #simDI_QT1_PB_OPEN;
                    #testTimer(IN := FALSE,
                               PT := T#1s);
                END_IF;
                
                // Avanzar después de 10s
                IF #outElapsedTime > T#10s THEN
                    #testStep := 10;
                END_IF;
                
            // PASO 10: Finalizado
            10:
                #testStatus := 'PASO 10: TEST COMPLETADO';
                #testExpectedResult := 'Revisar todos los pasos OK';
                #testEnable := FALSE;  // Detener test
                
        END_CASE;
        
    ELSE
        // Test no habilitado - reset
        #testStep := 0;
        #testStatus := 'Test detenido - Activar testEnable para iniciar';
        #testTimer(IN := FALSE,
                   PT := T#1s);
    END_IF;
    
    
    // ========================================================================
    // NETWORK 2: LLAMADA FB_IO_NORMALIZE
    // ========================================================================
    #fbIoNormalize(DI_SYS_AUTO := #simDI_SYS_AUTO,
                   DI_QT1_REMOTE_SEL := #simDI_QT1_REMOTE_SEL,
                   DI_QT1_PB_OPEN := #simDI_QT1_PB_OPEN,
                   DI_QT1_PB_CLOSE := #simDI_QT1_PB_CLOSE,
                   DI_QG1_REMOTE_SEL := #simDI_QG1_REMOTE_SEL,
                   DI_QG1_PB_OPEN := #simDI_QG1_PB_OPEN,
                   DI_QG1_PB_CLOSE := #simDI_QG1_PB_CLOSE,
                   DI_QG2_REMOTE_SEL := FALSE,
                   DI_QG2_PB_OPEN := FALSE,
                   DI_QG2_PB_CLOSE := FALSE,
                   DI_GD_READY := #simDI_GD_READY,
                   DI_GD_RUNNING := #simDI_GD_RUNNING,
                   DI_GD_ALARM := #simDI_GD_ALARM,
                   
                   MODE_AUTO => #outModeAuto,
                   REQ_MAN_QT1_OPEN => #outReqManQT1_Open,
                   REQ_MAN_QT1_CLOSE => #outReqManQT1_Close,
                   GD_READY => #outGD_Ready,
                   GD_RUNNING => #outGD_Running);
    
    
    // ========================================================================
    // NETWORK 3: LLAMADA FB_SCMTA
    // ========================================================================
    #fbScmta(ENABLE := TRUE,
             MODE_AUTO := #outModeAuto,
             RESET_FAULT := #simRESET_FAULT,
             
             QT1_STATE := #simQT1_STATE,
             QG1_STATE := #simQG1_STATE,
             QG2_STATE := #simQG2_STATE,
             
             GRID_V_L1L2 := #simGridV_L1L2,
             GRID_V_L2L3 := #simGridV_L2L3,
             GRID_V_L3L1 := #simGridV_L3L1,
             GRID_FREQ := #simGridFreq,
             GRID_MEASUREMENT_OK := #simGridMeasurementOk,
             
             GD_READY := #outGD_Ready,
             GD_RUNNING := #outGD_Running,
             GD_ALARM := #simDI_GD_ALARM,
             
             V_NOM := 380.0,
             V_MIN_PCT := 85.0,
             V_MAX_PCT := 110.0,
             FREQ_NOM := 50.0,
             FREQ_MIN := 49.0,
             FREQ_MAX := 51.0,
             
             STATE => #outState,
             STATE_NAME => #outStateName,
             REQ_SCMTA_OPEN_QT1 => #outReqScmtaOpenQT1,
             REQ_SCMTA_CLOSE_QT1 => #outReqScmtaCloseQT1,
             REQ_SCMTA_OPEN_QG1 => #outReqScmtaOpenQG1,
             REQ_SCMTA_CLOSE_QG1 => #outReqScmtaCloseQG1,
             DO_GD_START => #outDoGD_Start,
             DO_GD_STOP => #outDoGD_Stop,
             IS_ON_GRID => #outIsOnGrid,
             IS_ON_GD => #outIsOnGD,
             IS_IN_TRANSFER => #outIsInTransfer,
             GRID_OK => #outGridOk,
             GRID_FAIL => #outGridFail,
             ELAPSED_TIME => #outElapsedTime);
    
END_FUNCTION_BLOCK
