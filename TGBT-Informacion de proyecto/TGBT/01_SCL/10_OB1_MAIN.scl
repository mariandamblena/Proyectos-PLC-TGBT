(*
================================================================================
  ORGANIZATION BLOCK: OB1 (Main Cyclic Execution)
  Versión: 3.0
  Fecha: 2026-02-10
  Autor: Sistema SCMTA TGBT
================================================================================
  DESCRIPCIÓN:
  Programa principal cíclico del sistema SCMTA.
  Orquesta la ejecución secuencial de todos los Function Blocks.
  
  ARQUITECTURA:
  Network 1: FB_IO_NORMALIZE
  Network 2: FB_SCMTA
  Network 3: FB_SHED
  Network 4: FB_CMD_ARBITER
  Network 5: FB_OUTPUTS
  Network 6: Drivers MTZ (QT1, QG1, QG2)
  Network 7: Cálculos auxiliares (LoadPct, Uptime)
  
  TIEMPO DE CICLO RECOMENDADO: 100-200 ms
  
  IMPORTANTE:
  - Antes de usar este OB1, CREAR los Global DBs:
    · DATA_BUFF (o renombrar a DB_GLOBAL_STATUS)
    · DB_PARAMS
  - Los Instance DBs se crean automáticamente al compilar
  
================================================================================
*)

ORGANIZATION_BLOCK "Main"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
    
    // ========================================================================
    // NETWORK 1: NORMALIZACIÓN ENTRADAS/SALIDAS
    // ========================================================================
    // Convierte señales físicas DI → señales lógicas
    // Output: MODE_AUTO, *_REMOTE_ALLOWED, REQ_MAN_*, GD_READY/RUNNING/ALARM
    
    "01_FB_IO_NORMALIZE_DB"(
        // Inputs - Mapeo DI físicas (EJEMPLO - ajustar según hardware real)
        DI_SYS_AUTO := %I0.0,
        DI_QT1_REMOTE_SEL := %I0.1,
        DI_QT1_PB_OPEN := %I0.2,
        DI_QT1_PB_CLOSE := %I0.3,
        DI_QG1_REMOTE_SEL := %I0.4,
        DI_QG1_PB_OPEN := %I0.5,
        DI_QG1_PB_CLOSE := %I0.6,
        DI_QG2_REMOTE_SEL := %I1.0,
        DI_QG2_PB_OPEN := %I1.1,
        DI_QG2_PB_CLOSE := %I1.2,
        DI_GD_READY := %I1.3,
        DI_GD_RUNNING := %I1.4,
        DI_GD_ALARM := %I1.5,
        DI_GD2_READY := %I1.6,
        DI_GD2_RUNNING := %I1.7,
        DI_GD2_ALARM := %I2.1,
        
        // Outputs → DATA_BUFF (Global DB)
        MODE_AUTO => "DATA_BUFF".MODE_AUTO,
        MODE_MANUAL => "DATA_BUFF".MODE_MANUAL,
        QT1_REMOTE_ALLOWED => "DATA_BUFF".QT1_REMOTE_ALLOWED,
        QG1_REMOTE_ALLOWED => "DATA_BUFF".QG1_REMOTE_ALLOWED,
        QG2_REMOTE_ALLOWED => "DATA_BUFF".QG2_REMOTE_ALLOWED,
        REQ_MAN_QT1_OPEN => "DATA_BUFF".REQ_MAN_QT1_OPEN,
        REQ_MAN_QT1_CLOSE => "DATA_BUFF".REQ_MAN_QT1_CLOSE,
        REQ_MAN_QG1_OPEN => "DATA_BUFF".REQ_MAN_QG1_OPEN,
        REQ_MAN_QG1_CLOSE => "DATA_BUFF".REQ_MAN_QG1_CLOSE,
        REQ_MAN_QG2_OPEN => "DATA_BUFF".REQ_MAN_QG2_OPEN,
        REQ_MAN_QG2_CLOSE => "DATA_BUFF".REQ_MAN_QG2_CLOSE,
        GD_READY => "DATA_BUFF".GD_READY,
        GD_RUNNING => "DATA_BUFF".GD_RUNNING,
        GD_ALARM => "DATA_BUFF".GD_ALARM,
        GD2_READY => "DATA_BUFF".GD2_READY,
        GD2_RUNNING => "DATA_BUFF".GD2_RUNNING,
        GD2_ALARM => "DATA_BUFF".GD2_ALARM,
        DIAG_MODE_VALID => "DATA_BUFF".DIAG_MODE_VALID
    );
    
    
    // ========================================================================
    // NETWORK 2: MÁQUINA DE ESTADOS SCMTA (Transferencia Automática)
    // ========================================================================
    // Input: MODE_AUTO, estados interruptores, mediciones red, GD_READY
    // Output: REQ_SCMTA_*, DO_GD_START/STOP, flags estado (IS_ON_GRID, IS_ON_GD, etc.)
    
    "02_FB_SCMTA_DB"(
        // Control
        ENABLE := "DB_PARAMS".ENABLE_SCMTA,
        MODE_AUTO := "DATA_BUFF".MODE_AUTO,
        RESET_FAULT := %I2.0,  // TODO: mapear botón reset físico o HMI
        
        // Estados interruptores (de drivers Modbus)
        QT1_STATE := "DATA_BUFF".QT1_STATE,
        QG1_STATE := "DATA_BUFF".QG1_STATE,
        QG2_STATE := "DATA_BUFF".QG2_STATE,
        
        // Mediciones RED (de PM5350 vía Modbus)
        GRID_V_L1L2 := "DATA_BUFF".GRID_V_L1L2,
        GRID_V_L2L3 := "DATA_BUFF".GRID_V_L2L3,
        GRID_V_L3L1 := "DATA_BUFF".GRID_V_L3L1,
        GRID_FREQ := "DATA_BUFF".GRID_FREQ,
        GRID_MEASUREMENT_OK := "DATA_BUFF".GRID_MEASUREMENT_OK,
        
        // Señales GD1 (primario)
        GD_READY := "DATA_BUFF".GD_READY,
        GD_RUNNING := "DATA_BUFF".GD_RUNNING,
        GD_ALARM := "DATA_BUFF".GD_ALARM,
        
        // Señales GD2 (backup/redundante)
        GD2_READY := "DATA_BUFF".GD2_READY,
        GD2_RUNNING := "DATA_BUFF".GD2_RUNNING,
        GD2_ALARM := "DATA_BUFF".GD2_ALARM,
        
        // Parámetros configurables (de DB_PARAMS)
        V_NOM := "DB_PARAMS".V_NOM,
        V_MIN_PCT := "DB_PARAMS".V_MIN_PCT,
        V_MAX_PCT := "DB_PARAMS".V_MAX_PCT,
        FREQ_NOM := "DB_PARAMS".FREQ_NOM,
        FREQ_MIN := "DB_PARAMS".FREQ_MIN,
        FREQ_MAX := "DB_PARAMS".FREQ_MAX,
        T_OPEN_QT1 := "DB_PARAMS".T_OPEN_QT1,
        T_START_GD_DELAY := "DB_PARAMS".T_START_GD_DELAY,
        T_GD_READY_TIMEOUT := "DB_PARAMS".T_GD_READY_TIMEOUT,
        T_GD_STABILIZATION := "DB_PARAMS".T_GD_STABILIZATION,
        T_CLOSE_QG1 := "DB_PARAMS".T_CLOSE_QG1,
        T_CLOSE_QG2 := "DB_PARAMS".T_CLOSE_QG2,
        T_GRID_STABLE := "DB_PARAMS".T_GRID_STABLE,
        T_OPEN_QG1 := "DB_PARAMS".T_OPEN_QG1,
        T_OPEN_QG2 := "DB_PARAMS".T_OPEN_QG2,
        T_CLOSE_QT1 := "DB_PARAMS".T_CLOSE_QT1,
        T_GD_COOLDOWN := "DB_PARAMS".T_GD_COOLDOWN,
        T_GRID_FAIL_FILTER := "DB_PARAMS".T_GRID_FAIL_FILTER,
        
        // Outputs → DATA_BUFF
        STATE => "DATA_BUFF".SCMTA_STATE,
        STATE_NAME => "DATA_BUFF".SCMTA_STATE_NAME,
        REQ_SCMTA_OPEN_QT1 => "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QT1,
        REQ_SCMTA_CLOSE_QT1 => "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QT1,
        REQ_SCMTA_OPEN_QG1 => "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QG1,
        REQ_SCMTA_CLOSE_QG1 => "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QG1,
        REQ_SCMTA_OPEN_QG2 => "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QG2,
        REQ_SCMTA_CLOSE_QG2 => "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QG2,
        DO_GD_START => %Q0.0,
        DO_GD_STOP => %Q0.1,
        DO_GD2_START => %Q0.2,
        DO_GD2_STOP => %Q0.3,
        IS_ON_GRID => "DATA_BUFF".IS_ON_GRID,
        IS_ON_GD => "DATA_BUFF".IS_ON_GD,
        IS_ON_GD1 => "DATA_BUFF".IS_ON_GD1,
        IS_ON_GD2 => "DATA_BUFF".IS_ON_GD2,
        ACTIVE_GD => "DATA_BUFF".ACTIVE_GD,
        IS_IN_TRANSFER => "DATA_BUFF".IS_IN_TRANSFER,
        IS_FAULT => "DATA_BUFF".IS_FAULT,
        TRANSFER_TO_GD => "DATA_BUFF".TRANSFER_TO_GD,
        GRID_OK => "DATA_BUFF".GRID_OK,
        GRID_FAIL => "DATA_BUFF".GRID_FAIL,
        FAULT_CODE => "DATA_BUFF".FAULT_CODE,
        ELAPSED_TIME => "DATA_BUFF".ELAPSED_TIME,
        DIAG_LAST_TRANSFER_TIME => "DATA_BUFF".DIAG_LAST_TRANSFER_TIME,
        GD1_AVAILABLE => "DATA_BUFF".GD1_AVAILABLE,
        GD2_AVAILABLE => "DATA_BUFF".GD2_AVAILABLE
    );
    
    
    // ========================================================================
    // NETWORK 3: DESLASTRE Y REENGANCHE
    // ========================================================================
    // Input: IS_ON_GD, GD_LoadPct, TR_LoadPct, arrays SHED_ORDER/ENABLE
    // Output: REQ_SHED_OPEN/CLOSE[1..18]
    
    "03_FB_SHED_DB"(
        // Control
        ENABLE := "DB_PARAMS".ENABLE_SHED,
        MODE_AUTO := "DATA_BUFF".MODE_AUTO,
        IS_ON_GD := "DATA_BUFF".IS_ON_GD,
        IS_ON_GRID := "DATA_BUFF".IS_ON_GRID,
        IS_IN_TRANSFER := "DATA_BUFF".IS_IN_TRANSFER,
        TRANSFER_TO_GD := "DATA_BUFF".TRANSFER_TO_GD,
        
        // Mediciones
        GD_LoadPct := "DATA_BUFF".GD_LoadPct,
        TR_LoadPct := "DATA_BUFF".TR_LoadPct,
        
        // Parámetros deslastre GD (de DB_PARAMS)
        GD_SHED_ON := "DB_PARAMS".GD_SHED_ON,
        GD_SHED_OFF := "DB_PARAMS".GD_SHED_OFF,
        
        // Parámetros deslastre RED (de DB_PARAMS)
        GRID_SHED_ON := "DB_PARAMS".GRID_SHED_ON,
        GRID_SHED_OFF := "DB_PARAMS".GRID_SHED_OFF,
        
        // Parámetros tiempos (de DB_PARAMS)
        T_SHED_STEP := "DB_PARAMS".T_SHED_STEP,
        T_RECONNECT_STEP := "DB_PARAMS".T_RECONNECT_STEP,
        T_LOAD_FILTER := "DB_PARAMS".T_LOAD_FILTER,
        T_LOAD_CHECK_DELAY := "DB_PARAMS".T_LOAD_CHECK_DELAY,
        
        // Arrays configurables
        SHED_ORDER := "DB_PARAMS".SHED_ORDER,
        RECONNECT_ORDER := "DB_PARAMS".RECONNECT_ORDER,
        FEEDER_ESSENTIAL := "DB_PARAMS".FEEDER_ESSENTIAL,
        SHED_ENABLE := "DB_PARAMS".SHED_ENABLE,
        
        // Estados feeders
        FEEDER_STATE := "DATA_BUFF".FEEDER_STATE,
        
        // Outputs → 03_FB_SHED_DB / DATA_BUFF
        REQ_SHED_OPEN => "03_FB_SHED_DB".REQ_SHED_OPEN,
        REQ_SHED_CLOSE => "03_FB_SHED_DB".REQ_SHED_CLOSE,
        SHED_ACTIVE => "DATA_BUFF".SHED_ACTIVE,
        SHED_STEP => "DATA_BUFF".SHED_STEP,
        RECONNECT_ACTIVE => "DATA_BUFF".RECONNECT_ACTIVE,
        RECONNECT_STEP => "DATA_BUFF".RECONNECT_STEP,
        SHED_MODE => "DATA_BUFF".SHED_MODE,
        FEEDERS_SHED => "DATA_BUFF".FEEDERS_SHED,
        FEEDERS_ESSENTIAL_COUNT => "DATA_BUFF".FEEDERS_ESSENTIAL_COUNT,
        FEEDERS_NON_ESSENTIAL_COUNT => "DATA_BUFF".FEEDERS_NON_ESSENTIAL_COUNT,
        DIAG_LOAD_OVER_LIMIT => "DATA_BUFF".DIAG_LOAD_OVER_LIMIT,
        DIAG_GD_LOAD_OK => "DATA_BUFF".DIAG_GD_LOAD_OK,
        DIAG_GRID_LOAD_OK => "DATA_BUFF".DIAG_GRID_LOAD_OK
    );
    
    
    // ========================================================================
    // NETWORK 4: ÁRBITRO DE COMANDOS (Enclavamiento + Priorización)
    // ========================================================================
    // Input: REQ_SCMTA_*, REQ_SHED_*, REQ_MAN_*, permisos LOCAL/REMOTO
    // Output: CMD_* (comandos finales para drivers Modbus)
    
    "04_FB_CMD_ARBITER_DB"(
        // Requests SCMTA (Prioridad 1)
        REQ_SCMTA_OPEN_QT1 := "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QT1,
        REQ_SCMTA_CLOSE_QT1 := "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QT1,
        REQ_SCMTA_OPEN_QG1 := "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QG1,
        REQ_SCMTA_CLOSE_QG1 := "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QG1,
        REQ_SCMTA_OPEN_QG2 := "02_FB_SCMTA_DB".REQ_SCMTA_OPEN_QG2,
        REQ_SCMTA_CLOSE_QG2 := "02_FB_SCMTA_DB".REQ_SCMTA_CLOSE_QG2,
        
        // Requests SHED (Prioridad 2)
        REQ_SHED_OPEN := "03_FB_SHED_DB".REQ_SHED_OPEN,
        REQ_SHED_CLOSE := "03_FB_SHED_DB".REQ_SHED_CLOSE,
        
        // Requests MANUAL (Prioridad 3)
        REQ_MAN_QT1_OPEN := "DATA_BUFF".REQ_MAN_QT1_OPEN,
        REQ_MAN_QT1_CLOSE := "DATA_BUFF".REQ_MAN_QT1_CLOSE,
        REQ_MAN_QG1_OPEN := "DATA_BUFF".REQ_MAN_QG1_OPEN,
        REQ_MAN_QG1_CLOSE := "DATA_BUFF".REQ_MAN_QG1_CLOSE,
        REQ_MAN_QG2_OPEN := "DATA_BUFF".REQ_MAN_QG2_OPEN,
        REQ_MAN_QG2_CLOSE := "DATA_BUFF".REQ_MAN_QG2_CLOSE,
        
        // Modo y permisos
        MODE_AUTO := "DATA_BUFF".MODE_AUTO,
        MODE_MANUAL := "DATA_BUFF".MODE_MANUAL,
        QT1_REMOTE_ALLOWED := "DATA_BUFF".QT1_REMOTE_ALLOWED,
        QG1_REMOTE_ALLOWED := "DATA_BUFF".QG1_REMOTE_ALLOWED,
        QG2_REMOTE_ALLOWED := "DATA_BUFF".QG2_REMOTE_ALLOWED,
        FEEDER_REMOTE_ALLOWED := "DATA_BUFF".FEEDER_REMOTE_ALLOWED,
        
        // Estados interruptores
        QT1_STATE := "DATA_BUFF".QT1_STATE,
        QG1_STATE := "DATA_BUFF".QG1_STATE,
        QG2_STATE := "DATA_BUFF".QG2_STATE,
        FEEDER_STATE := "DATA_BUFF".FEEDER_STATE,
        
        // Outputs → 04_FB_CMD_ARBITER_DB (comandos finales)
        CMD_OPEN_QT1 => "04_FB_CMD_ARBITER_DB".CMD_OPEN_QT1,
        CMD_CLOSE_QT1 => "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QT1,
        CMD_OPEN_QG1 => "04_FB_CMD_ARBITER_DB".CMD_OPEN_QG1,
        CMD_CLOSE_QG1 => "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QG1,
        CMD_OPEN_QG2 => "04_FB_CMD_ARBITER_DB".CMD_OPEN_QG2,
        CMD_CLOSE_QG2 => "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QG2,
        CMD_OPEN_FEEDER => "04_FB_CMD_ARBITER_DB".CMD_OPEN_FEEDER,
        CMD_CLOSE_FEEDER => "04_FB_CMD_ARBITER_DB".CMD_CLOSE_FEEDER,
        
        // Bloqueos y alarmas
        BLOCK_LOCAL => "DATA_BUFF".BLOCK_LOCAL,
        BLOCK_INTERLOCK => "DATA_BUFF".BLOCK_INTERLOCK,
        BLOCK_CONFLICT => "DATA_BUFF".BLOCK_CONFLICT,
        ALM_INTERLOCK_VIOLATION => "DATA_BUFF".ALM_INTERLOCK_VIOLATION
    );
    
    
    // ========================================================================
    // NETWORK 5: GESTIÓN DE SALIDAS (Pilotos, Alarmas, HMI)
    // ========================================================================
    // Input: Estados SCMTA, alarmas, deslastre
    // Output: DO pilotos, bocina, baliza, señales HMI
    
    "05_FB_OUTPUTS_DB"(
        // Estados sistema
        IS_ON_GRID := "DATA_BUFF".IS_ON_GRID,
        IS_ON_GD := "DATA_BUFF".IS_ON_GD,
        IS_IN_TRANSFER := "DATA_BUFF".IS_IN_TRANSFER,
        IS_FAULT := "DATA_BUFF".IS_FAULT,
        STATE := "DATA_BUFF".SCMTA_STATE,
        STATE_NAME := "DATA_BUFF".SCMTA_STATE_NAME,
        FAULT_CODE := "DATA_BUFF".FAULT_CODE,
        
        // Alarmas
        ALM_INTERLOCK_VIOLATION := "DATA_BUFF".ALM_INTERLOCK_VIOLATION,
        BLOCK_INTERLOCK := "DATA_BUFF".BLOCK_INTERLOCK,
        GRID_FAIL := "DATA_BUFF".GRID_FAIL,
        GD_ALARM := "DATA_BUFF".GD_ALARM,
        
        // Deslastre
        SHED_ACTIVE := "DATA_BUFF".SHED_ACTIVE,
        FEEDERS_SHED := "DATA_BUFF".FEEDERS_SHED,
        
        // Control
        ENABLE_HORN := "DB_PARAMS".ENABLE_HORN,
        ACK_ALARM := %I2.1,  // TODO: mapear botón ACK físico o HMI
        
        // Outputs → DO físicas (EJEMPLO - ajustar según hardware)
        DO_PILOT_ON_GRID => %Q1.0,
        DO_PILOT_ON_GD => %Q1.1,
        DO_PILOT_TRANSFER => %Q1.2,
        DO_PILOT_FAULT => %Q1.3,
        DO_PILOT_SHED => %Q1.4,
        DO_ALARM_HORN => %Q1.5,
        DO_ALARM_BEACON => %Q1.6,
        
        // Outputs HMI
        HMI_ALARM_ACTIVE => "DATA_BUFF".HMI_ALARM_ACTIVE,
        HMI_ALARM_TEXT => "DATA_BUFF".HMI_ALARM_TEXT
    );
    
    
    // ========================================================================
    // NETWORK 6: DRIVERS MODBUS MTZ (QT1, QG1, QG2)
    // ========================================================================
    
    // Driver QT1 (Interruptor RED)
    "07_FB_MTZ_DRIVER_DB_QT1"(
        ENABLE := TRUE,
        CMD_OPEN := "04_FB_CMD_ARBITER_DB".CMD_OPEN_QT1,
        CMD_CLOSE := "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QT1,
        CMD_RESET := FALSE,
        SLAVE_ID := "DB_PARAMS".SLAVE_ID_QT1,
        PASSWORD := "DB_PARAMS".PASSWORD_MTZ_QT1,
        T_POLL_TIMEOUT := "DB_PARAMS".T_MODBUS_POLL_TIMEOUT,
        T_CONFIRM_TIMEOUT := "DB_PARAMS".T_MODBUS_CONFIRM_TIMEOUT,
        
        CB_STATE => "DATA_BUFF".QT1_STATE,
        CB_TRIPPED => "DATA_BUFF".QT1_TRIPPED,
        CB_READY => "DATA_BUFF".QT1_READY
    );
    
    // Driver QG1 (Interruptor GD01)
    "07_FB_MTZ_DRIVER_DB_QG1"(
        ENABLE := TRUE,
        CMD_OPEN := "04_FB_CMD_ARBITER_DB".CMD_OPEN_QG1,
        CMD_CLOSE := "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QG1,
        CMD_RESET := FALSE,
        SLAVE_ID := "DB_PARAMS".SLAVE_ID_QG1,
        PASSWORD := "DB_PARAMS".PASSWORD_MTZ_QG1,
        T_POLL_TIMEOUT := "DB_PARAMS".T_MODBUS_POLL_TIMEOUT,
        T_CONFIRM_TIMEOUT := "DB_PARAMS".T_MODBUS_CONFIRM_TIMEOUT,
        
        CB_STATE => "DATA_BUFF".QG1_STATE,
        CB_TRIPPED => "DATA_BUFF".QG1_TRIPPED,
        CB_READY => "DATA_BUFF".QG1_READY
    );
    
    // Driver QG2 (Interruptor GD02)
    "07_FB_MTZ_DRIVER_DB_QG2"(
        ENABLE := TRUE,
        CMD_OPEN := "04_FB_CMD_ARBITER_DB".CMD_OPEN_QG2,
        CMD_CLOSE := "04_FB_CMD_ARBITER_DB".CMD_CLOSE_QG2,
        CMD_RESET := FALSE,
        SLAVE_ID := "DB_PARAMS".SLAVE_ID_QG2,
        PASSWORD := "DB_PARAMS".PASSWORD_MTZ_QG2,
        T_POLL_TIMEOUT := "DB_PARAMS".T_MODBUS_POLL_TIMEOUT,
        T_CONFIRM_TIMEOUT := "DB_PARAMS".T_MODBUS_CONFIRM_TIMEOUT,
        
        CB_STATE => "DATA_BUFF".QG2_STATE,
        CB_TRIPPED => "DATA_BUFF".QG2_TRIPPED,
        CB_READY => "DATA_BUFF".QG2_READY
    );
    
    
    // ========================================================================
    // NETWORK 7: CÁLCULOS AUXILIARES
    // ========================================================================
    
    // Cálculo GD_LoadPct (carga GD en porcentaje)
    // LoadPct = (P_TOTAL / P_NOMINAL) * 100
    IF "DB_PARAMS".GD_POWER_NOMINAL > 0.0 THEN
        "DATA_BUFF".GD_LoadPct := 
            ("DATA_BUFF".GD_P_TOTAL / "DB_PARAMS".GD_POWER_NOMINAL) * 100.0;
    ELSE
        "DATA_BUFF".GD_LoadPct := 0.0;
    END_IF;
    
    // Cálculo TR_LoadPct (carga transformador en porcentaje)
    IF "DB_PARAMS".TR_POWER_NOMINAL > 0.0 THEN
        "DATA_BUFF".TR_LoadPct := 
            ("DATA_BUFF".TR_P_TOTAL / "DB_PARAMS".TR_POWER_NOMINAL) * 100.0;
    ELSE
        "DATA_BUFF".TR_LoadPct := 0.0;
    END_IF;
    
    // Contador Uptime (tiempo desde inicio PLC)
    // TODO: implementar con timer acumulativo
    
    // Incrementar contador transferencias al entrar en estado ON_GD
    // TODO: detectar flanco IS_ON_GD y incrementar TRANSFER_COUNT
    
END_ORGANIZATION_BLOCK
