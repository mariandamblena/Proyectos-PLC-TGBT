@startuml SCMTA_GD2_StateMachine

title Sistema SCMTA con GD2 (N+1 Redundancia) - M√°quina de Estados Transferencia Autom√°tica

[*] --> INIT

state INIT {
    INIT : Inicializaci√≥n sistema
    INIT : Verificar estado interruptores
    INIT : QT1 (RED) / QG1 (GD01) / QG2 (GD02)
}

INIT --> NORMAL_ON_GRID : QT1 cerrado\n(operaci√≥n normal)
INIT --> ON_GD1 : QG1 cerrado\n(ya en GD1)
INIT --> ON_GD2 : QG2 cerrado\n(ya en GD2)
INIT --> CLOSE_QT1 : Red OK y todos abiertos
INIT --> START_GD1 : Sin red y todos abiertos

state "NORMAL_ON_GRID" as NORMAL {
    NORMAL : ‚úì Operaci√≥n normal con RED
    NORMAL : QT1 cerrado, QG1/QG2 abiertos
    NORMAL : IS_ON_GRID = TRUE
}

NORMAL --> GRID_FAIL_DETECTED : GRID_FAIL = TRUE\nMODE_AUTO = TRUE

state GRID_FAIL_DETECTED {
    GRID_FAIL_DETECTED : Falla de RED detectada
    GRID_FAIL_DETECTED : (tensi√≥n/frecuencia/fase)
    GRID_FAIL_DETECTED : Selecci√≥n GD: prioridad GD1 > GD2
}

GRID_FAIL_DETECTED --> OPEN_QT1

state OPEN_QT1 {
    OPEN_QT1 : Abriendo QT1
    OPEN_QT1 : REQ_SCMTA_OPEN_QT1 = TRUE
    OPEN_QT1 : Timeout: 2s
}

OPEN_QT1 --> START_GD1_DELAY : QT1 abierto\n(confirmado)
OPEN_QT1 --> FAULT_LOCKOUT : Timeout

state START_GD1_DELAY {
    START_GD1_DELAY : Delay 3s antes arranque GD1
    START_GD1_DELAY : (seguridad)
}

START_GD1_DELAY --> START_GD1 : Timer 3s

state START_GD1 {
    START_GD1 : Dando orden marcha GD1
    START_GD1 : DO_GD1_START = TRUE
    START_GD1 : (GD primario)
}

START_GD1 --> WAIT_GD1_READY : GD1_RUNNING = TRUE
START_GD1 --> START_GD2_DELAY : GD1_ALARM = TRUE\n(failover GD2)
START_GD1 --> FAULT_LOCKOUT : GD1_ALARM = TRUE\nAND GD2_NOT_AVAILABLE

state "START_GD2_DELAY" as START_GD2_DELAY {
    START_GD2_DELAY : üîÑ Failover a GD2
    START_GD2_DELAY : GD1 con falla ‚Üí intentar GD2
    START_GD2_DELAY : Delay 3s seguridad
}

START_GD2_DELAY --> START_GD2 : Timer 3s

state START_GD2 {
    START_GD2 : Dando orden marcha GD2
    START_GD2 : DO_GD2_START = TRUE
    START_GD2 : (GD backup/redundante)
}

START_GD2 --> WAIT_GD2_READY : GD2_RUNNING = TRUE
START_GD2 --> FAULT_LOCKOUT : GD2_ALARM = TRUE

state WAIT_GD1_READY {
    WAIT_GD1_READY : Esperando GD1_READY
    WAIT_GD1_READY : + estabilizaci√≥n 5s
    WAIT_GD1_READY : Timeout: 30s
}

WAIT_GD1_READY --> CLOSE_QG1 : GD1_READY estable 5s
WAIT_GD1_READY --> START_GD2_DELAY : Timeout o GD1_ALARM\n(failover GD2)
WAIT_GD1_READY --> FAULT_LOCKOUT : Timeout y GD2_NOT_AVAILABLE

state "WAIT_GD2_READY" as WAIT_GD2_READY {
    WAIT_GD2_READY : Esperando GD2_READY
    WAIT_GD2_READY : + estabilizaci√≥n 5s
    WAIT_GD2_READY : Timeout: 30s
}

WAIT_GD2_READY --> CLOSE_QG2 : GD2_READY estable 5s
WAIT_GD2_READY --> FAULT_LOCKOUT : Timeout o GD2_ALARM

state CLOSE_QG1 {
    CLOSE_QG1 : Cerrando QG1
    CLOSE_QG1 : REQ_SCMTA_CLOSE_QG1 = TRUE
    CLOSE_QG1 : Timeout: 2s
    CLOSE_QG1 : (Enclavamiento: QT1=0, QG2=0)
}

CLOSE_QG1 --> ON_GD1 : QG1 cerrado
CLOSE_QG1 --> FAULT_LOCKOUT : Timeout

state "CLOSE_QG2" as CLOSE_QG2 {
    CLOSE_QG2 : Cerrando QG2
    CLOSE_QG2 : REQ_SCMTA_CLOSE_QG2 = TRUE
    CLOSE_QG2 : Timeout: 2s
    CLOSE_QG2 : (Enclavamiento: QT1=0, QG1=0)
}

CLOSE_QG2 --> ON_GD2 : QG2 cerrado
CLOSE_QG2 --> FAULT_LOCKOUT : Timeout

state "ON_GD1" as ON_GD1_STATE {
    ON_GD1_STATE : ‚úì Operaci√≥n con GD1 (primario)
    ON_GD1_STATE : QG1 cerrado, QT1/QG2 abiertos
    ON_GD1_STATE : IS_ON_GD1 = TRUE
    ON_GD1_STATE : (Deslastre activo si carga > 90%)
}

ON_GD1_STATE --> GRID_RETURN_DETECTED : GRID_OK = TRUE\nMODE_AUTO = TRUE
ON_GD1_STATE --> SWITCH_GD1_TO_GD2 : GD1_ALARM = TRUE\nAND GD2_AVAILABLE
ON_GD1_STATE --> FAULT_LOCKOUT : GD1_ALARM = TRUE\nAND GD2_NOT_AVAILABLE

state "ON_GD2" as ON_GD2_STATE {
    ON_GD2_STATE : ‚úì Operaci√≥n con GD2 (backup)
    ON_GD2_STATE : QG2 cerrado, QT1/QG1 abiertos
    ON_GD2_STATE : IS_ON_GD2 = TRUE
    ON_GD2_STATE : (Deslastre activo si carga > 90%)
}

ON_GD2_STATE --> GRID_RETURN_DETECTED : GRID_OK = TRUE\nMODE_AUTO = TRUE
ON_GD2_STATE --> SWITCH_GD2_TO_GD1 : GD2_ALARM = TRUE\nAND GD1_AVAILABLE
ON_GD2_STATE --> FAULT_LOCKOUT : GD2_ALARM = TRUE\nAND GD1_NOT_AVAILABLE

state "SWITCH_GD1_TO_GD2" as SWITCH_GD1_TO_GD2 {
    SWITCH_GD1_TO_GD2 : üîÑ Transferencia GD1 ‚Üí GD2
    SWITCH_GD1_TO_GD2 : 1. Abrir QG1
    SWITCH_GD1_TO_GD2 : 2. Arrancar GD2
    SWITCH_GD1_TO_GD2 : 3. Esperar GD2_READY
    SWITCH_GD1_TO_GD2 : 4. Cerrar QG2
}

SWITCH_GD1_TO_GD2 --> START_GD2 : Secuencia iniciada

state "SWITCH_GD2_TO_GD1" as SWITCH_GD2_TO_GD1 {
    SWITCH_GD2_TO_GD1 : üîÑ Transferencia GD2 ‚Üí GD1
    SWITCH_GD2_TO_GD1 : 1. Abrir QG2
    SWITCH_GD2_TO_GD1 : 2. Arrancar GD1
    SWITCH_GD2_TO_GD1 : 3. Esperar GD1_READY
    SWITCH_GD2_TO_GD1 : 4. Cerrar QG1
}

SWITCH_GD2_TO_GD1 --> START_GD1 : Secuencia iniciada

state GRID_RETURN_DETECTED {
    GRID_RETURN_DETECTED : Retorno de RED detectado
}

GRID_RETURN_DETECTED --> WAIT_GRID_STABLE

state WAIT_GRID_STABLE {
    WAIT_GRID_STABLE : Esperando estabilidad RED
    WAIT_GRID_STABLE : Timer: 120s
}

WAIT_GRID_STABLE --> OPEN_ACTIVE_GD : Timer 120s cumplido
WAIT_GRID_STABLE --> ON_GD1_STATE : GRID_FAIL = TRUE\n(rebote) y GD1 activo
WAIT_GRID_STABLE --> ON_GD2_STATE : GRID_FAIL = TRUE\n(rebote) y GD2 activo

state "OPEN_ACTIVE_GD" as OPEN_ACTIVE_GD {
    OPEN_ACTIVE_GD : Abriendo GD activo
    OPEN_ACTIVE_GD : (QG1 o QG2 seg√∫n cu√°l est√© cerrado)
}

OPEN_ACTIVE_GD --> CLOSE_QT1 : GD abierto confirmado
OPEN_ACTIVE_GD --> FAULT_LOCKOUT : Timeout

state CLOSE_QT1 {
    CLOSE_QT1 : Cerrando QT1
    CLOSE_QT1 : REQ_SCMTA_CLOSE_QT1 = TRUE
    CLOSE_QT1 : Timeout: 2s
    CLOSE_QT1 : (Enclavamiento verificado)
}

CLOSE_QT1 --> GD_COOLDOWN : QT1 cerrado
CLOSE_QT1 --> FAULT_LOCKOUT : Timeout

state "GD_COOLDOWN" as GD_COOLDOWN {
    GD_COOLDOWN : Cooldown GD activo 60s
    GD_COOLDOWN : Luego DO_GD_STOP = TRUE
    GD_COOLDOWN : (Parar GD1 o GD2 seg√∫n cu√°l estaba activo)
}

GD_COOLDOWN --> NORMAL : Timer 60s\n(GD parado)

state "FAULT_LOCKOUT" as FAULT {
    FAULT : ‚ö† FALLA - Lockout
    FAULT : IS_FAULT = TRUE
    FAULT : Requiere RESET_FAULT manual
    FAULT : (Ver FAULT_CODE)
}

FAULT --> NORMAL : RESET_FAULT = TRUE\nGRID_OK = TRUE
FAULT --> ON_GD1_STATE : RESET_FAULT = TRUE\nGRID_FAIL = TRUE\nGD1_AVAILABLE
FAULT --> ON_GD2_STATE : RESET_FAULT = TRUE\nGRID_FAIL = TRUE\nGD2_AVAILABLE

note right of FAULT
    C√≥digos de falla:
    101: Timeout Open QT1
    102: GD1 no alcanz√≥ READY
    103: Timeout Close QG1
    104: Timeout Open QG1
    105: Timeout Close QT1
    106: Alarma GD1
    107: Violaci√≥n enclavamiento
    108: Estado desconocido
    ---
    202: GD2 no alcanz√≥ READY
    203: Timeout Close QG2
    204: Timeout Open QG2
    206: Alarma GD2
    209: Ambos GD no disponibles
end note

note bottom of NORMAL
    PRIORIDAD: RED > GD1 > GD2
    Retorno autom√°tico RED
    (sin confirmaci√≥n operador)
end note

note bottom of ON_GD1_STATE
    GD1 = PRIMARIO
    Deslastre si carga > 90%
    Failover a GD2 si GD1_ALARM
    (transferencia autom√°tica)
end note

note bottom of ON_GD2_STATE
    GD2 = BACKUP/REDUNDANTE
    Solo opera si:
    - GD1 con falla/alarma
    - GD1 no disponible
    Puede volver a GD1 si GD1 OK
end note

note left of START_GD2
    Redundancia N+1:
    2 grupos di√©sel
    1 operando + 1 backup
    Failover autom√°tico
    Carga compartida NO soportada
    (solo uno cerrado a la vez)
end note

@enduml
